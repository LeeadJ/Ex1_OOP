Algorithm:
1. First we get a Call csv.
2. We loop through the call, and run by each call.
3. Check if the call is UP or DOWN. Deppending on which state we run through the csv and check which calls are relevant according
   to the timeStamp and state. (Id the elevator is now in the same direction as the call or the call timestamp is greater than
   the elevator floor timestamp - the call is irelevant.)
4. When finishing the loop, every call's elevator index that is different from -1, gets moved to an outputfile.
5. When finishing all the calls, we will sort the output file according to the timestamp.

Class:
1) Building(json):
    1. The __init__ receives a JSON file and extracts the key values:
        - Minimum Floor.
        - Maximum Floor.
        - elevator list.
        - Number of elevators.
    2) The index contains an elevator list:
        - Each index contains an elevator(imported from class - elevator).
///////////////////////////////////////////////////////////////////////////////////////////////////////
2) Elevator():
    1. The __init__ receives information from the Building class and initializes an elevator:
            - Elevator ID (index in the elevator-list)
            - Elevator Speed
            - Minimum floor of the elevator.
            - Maximum floor of the elevator.
            - Door closing time.
            - Door opening time.
            - Start time (time until the elevator reaches full speed).
            - Stop time (time until elevator reaches a complete stop)
    2. The __init__ also contains a Call-List.
            - The call list will hold the upcoming calls the elevator need to attend to.
            - Every index represents a call.
            - Each calls will be in ascending order, according to their timestamps. *****************
    3. The __init__ also contains a Finish-Time.
            - The Finish-time will update itself according to the last call in the call-list.
            - The algorithm will know to choose an elevator according the their Finish-timestamp.
    4. The __init__ also contains a Floor Timestamp dictionary (key='floor number'(int) : value='timestamp(float)).
            - This dictionary allows us to see what the timestamp of the elevator at each floor.
            - This will help us determine if to add a call to the elevator call list.
    Functions:
    1) src2dest_time(curr_elevator, curr_call): {return total_time}
        - recieves an elevator and a call.
        - return total time from the pickup on src to drop off on dest
    2) added_call_time_Adjuster(self, added_call):{VOID}
        - This function recieves a call and adjust the elevator dictionary timestamp accordingly.
        - If the elevator is UP, the call origin floor in the dictionary is set to the call origin.timestamp,
          and adds to each floor the amount of time according to the elevator preformance.
    3) add_default_time(self, call_dest, call_src) {VOID}
        - This function updates the elevator dictionary timestamp from the floors after the call destination.
    4) get_floorTimestamp(self, floor):{return floor timestamp}
        - This function returns the time-stamp of a given floor.
        - If the floor is not in the range an exception will be thrown.
    5) is_call_relevant(self, call):{returns boolean}
        - This function checks if the call timestamp is smaller or equal to the timestamp of the elevator at the floor
          of the call.
          elevator dictionary.
        - Returns true or false.
    6) is_elevator_UP(self) {boolean}
        - rRturns true if the time-stamp at maxfloor is greater than the time-stamp at maxfloor -1
    7) adjust_time_for_new_direction(call)
        - The calls are sorted. If we get a call that has a timestamp greater than the the timestamp of the elevator at the
          max floor (or minfloor), it meant the elevator need to update it's timestamp in a DOWN (or UP) direction.
        - This function will get a call and update the timestamp according to the direction.
    Functions2
    1) src2dest_time(curr_elevator, curr_call): {return total_time}
        - recieves an elevator and a call.
        - return total time from the pickup on src to drop off on dest
    2) time_range() {return time}
        - This function loops through the floor timestamp of an elevator.
        - At each floor the function returns a time range possible for a call to be taken.
        - At each floor the function will calculate the stop, close door/open and start time.

///////////////////////////////////////////////////////////////////////////////////////////////////////
3)Calls(csv):
    Here the initializer will receive a list from the call list.
    - The list will represent a single call.
    - Each index of the list will represent a certain value from the call (0-5)

    Functions:
    1) is_UP_Call() {boolean}
        - Returns true if the dest floor is greater than the origin floor (GoingUP)
///////////////////////////////////////////////////////////////////////////////////////////////////////
4) Time Library:
    4.1) This library will place all the time static functions in order to calculate the best elevator.
        Function:
        1) timeStamp_at_floor(curr_elevator, floor): {return time-stamp at given floor}
            - Uses the elevator floor time=stamp dictionary.



***
Fixing the Allocate problem:
Problem:
    The output puts all the calls in the elevator with the fastest speed and not by the best RELEVENT elevator.
Why is it happening:
    - Each time we choose an elevator, we then wipe all the elevators and reset the floor timestamp doct to 0.0.
    - When we add new calls, we add the first call to 0.0, and then the algorith, will again say return the fastest elevator by it's speed.
    - That causes all the calls to be placed in the fastest elevator by speed and cancels out all the other elevators.
Fix:
    - First we need to update the finish timestamp after each chosen elevator (DONE)
    - Base Case: - The first group of calls were placed in e1 (DOWN calls) and now the finish timestamp is 20.37 at the minFloor.
                 - The next call is at 16.95 (UP call).
                 - It makes sense that e0 will take the call and NOT e1.
                 - What is happening is that e1 is taking that call.
    - We need to check what the Finish timestamp is.
    - If the new call timestamp is less than an elevators finish timestamp then don't place any calls in that elevator.
    - Place the calls in the other elevator which have a finish timestamp the is less than the calls timestamp.
    - If we do NOT have an elevator that meets the condition then place it in the elevator based on the old allocate.


